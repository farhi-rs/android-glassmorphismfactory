package com.flame.ui;

import android.app.Activity;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.PorterDuffColorFilter;
import android.graphics.PorterDuff;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Path.Direction;
import android.graphics.RectF;
import android.graphics.drawable.GradientDrawable;
import android.view.Window;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import com.google.android.renderscript.Toolkit;
import java.util.ArrayList;
import java.util.HashMap;


/* A Glassmorphism effect factory class that generates blur to views intelligently, at need and using less resources as possible (I guess) */
public class GlassmorphismFactory {
    
    
    /* BlurListener class used in setBlurListener
    
    * whenBlurIsReady called when the GlassmorphismDrawable is ready to be drawn
    
    * whenResetBlur called when the generator needs reset the previous setted GlassmorphismDrawable (Its only needed when including the view itself in the blur to avoid blur duplications, otherwise its not needed, just reset what you did with the previous GlassmorphismDrawable [background/foreground] ). */
    public static class BlurListener {
        public void whenBlurIsReady(View view, GlassmorphismDrawable resultBlur) {}
        public void whenResetBlur(View view) {}    
    }
    
    /* Private Drawable class called GlassmorphismDrawable, it holds the generated blurred bitmap and it only get generated by GlassmorphismFactory class 
    
    * Since its a Drawable, you can apply it as a background/foreground for the selected view or other views (not recommend, looks weird and useless)
    
    * GlassmorphismDrawable have both features of GradientDrawable and BitmapDrawable, it can have rounded corners and you can apply a color filter to it
    
    * And you still can add a gradient in top of it, the Glassmorphism bitmap always get drawn at the bottom layer of the drawable and then the rest of the GradientDrawable get drawn later in the top
    
    * Added methods : Bitmap getBitmap() | void setColorFilter(ColorFilter) | setColorFilter(int, PorterDuff.Mode) | void setColorFilter(int) | Paint getPaint() */
    static class GlassmorphismDrawable extends GradientDrawable {
        View relatedView;
        Bitmap blurredBitmap;
        float[] cornerRadii = new float[8];
        float cornerRadius = -1;
        int strokeWidth;
        Paint glassmorphismPaint = new Paint();
        ColorFilter colorFilter;
        public GlassmorphismDrawable(View relatedView, Bitmap blurredBitmap) {
            super();
            this.relatedView = relatedView;
            this.blurredBitmap = blurredBitmap;
            glassmorphismPaint.setAntiAlias(true);
        }
        public Bitmap getBitmap() {
            return blurredBitmap;
        }
        @Override
        public void setCornerRadius(float radius) {
            this.cornerRadius = radius;
            this.cornerRadii = new float[8];
            super.setCornerRadius(radius);
        }
        @Override
        public void setCornerRadii(float[] radii) {
            this.cornerRadii = radii;
            this.cornerRadius = -1;
            super.setCornerRadii(radii);
        }
        @Override
        public void setStroke(int strokeWidth, int strokeColor) {
            this.strokeWidth = strokeWidth;
            super.setStroke(strokeWidth, strokeColor);
        }
        @Override
        public void draw(Canvas canvas) {
            if (blurredBitmap != null) {
                int blurRadius = blurRadiusForEachView.containsKey(relatedView) ? blurRadiusForEachView.get(relatedView) : defaultBlurRadius;
                canvas.save();
                Path cornersPath = new Path();
                RectF cornersPathRect = new RectF(strokeWidth/2f, strokeWidth/2f, canvas.getWidth() - strokeWidth/2f, canvas.getHeight() - strokeWidth/2f);
                if (cornerRadius < 0) {
                    cornersPath.addRoundRect(cornersPathRect, cornerRadii, Path.Direction.CW);
                } else {
                    cornersPath.addRoundRect(cornersPathRect, cornerRadius, cornerRadius, Path.Direction.CW);
                }
                canvas.clipPath(cornersPath);
                canvas.drawBitmap(blurredBitmap, -blurRadius, -blurRadius, glassmorphismPaint);
                canvas.restore();
            }
            super.draw(canvas);
        }
        
        public void setColorFilter(int color) {
            setColorFilter(color, PorterDuff.Mode.LIGHTEN);
        }
        
        public void setColorFilter(int color, PorterDuff.Mode mode) {
            setColorFilter(new PorterDuffColorFilter(color, mode));
        }
        
        public void setColorFilter(ColorFilter filter) {
            this.colorFilter = filter;
            glassmorphismPaint.setColorFilter(colorFilter);
            invalidateSelf();
        }
        
        public Paint getPaint() {
            return glassmorphismPaint;
        }
    }
    
    
    
    static Window relatedWindow;
    static HashMap<View, BlurListener> listeners = new HashMap();
    static HashMap<View, ViewTreeObserver.OnPreDrawListener> cachedOnPreDrawListeners = new HashMap();
    static HashMap<View, Integer> blurRadiusForEachView = new HashMap();
    static int defaultBlurRadius = 25;
    static HashMap<View, Boolean> includeViewsStatus = new HashMap();
    static boolean blurGeneratingStarted;
    
    
    
    /* This method links a activity to GlassmorphismFactory (actually the window of it) */
    public static void setActivity(Activity act) {
        if (act == null) throw new IllegalArgumentException("Cannot setup GlassmorphismFactory with a null activity");
        setWindow(act.getWindow());
    }
    
    /* This method links a window to GlassmorphismFactory */
    public static void setWindow(Window window) {
        if (window == null) throw new IllegalArgumentException("Cannot setup GlassmorphismFactory with a null window");
        stopGeneratingBlur();
        listeners.clear();
        blurRadiusForEachView.clear();
        relatedWindow = window;
    }
    
    /* This method links a blur listener to a view
    * It also link the view to the GlassmorphismFactory for preparation
    
    * This method should always be called before startGeneratingBlur method or nothing is gonna start */
    public static void setBlurListener(View view, BlurListener lis) {
        if (view == null) throw new IllegalArgumentException("Null View argument in setBlurListener.");
        if (lis == null) throw new IllegalArgumentException("Null BlurListener argument in setBlurListener.");
        listeners.put(view, lis);
    }
    
    /* This method specifies a blur radius value to a view
    
    * Blur radius is always confined between 0 and 25 */
    public static void setBlurRadius(View view, int radius) {
        if (view == null) throw new IllegalArgumentException("Cannot setBlurRadius of a null View.");
        if (! listeners.containsKey(view)) throw new IllegalArgumentException("Call setBlurListener first then call setBlurRadius.");
        if (radius < 0 || radius > 25) throw new IllegalArgumentException("Blur radius must be a positive number and less or equals to 25, given value : ".concat(String.valueOf(radius)));
        blurRadiusForEachView.put(view, radius);
        if (blurGeneratingStarted) view.invalidate();
    }
    
    /* Make the linked view be included in Glassmorphism blur
    
    * Useful when applying the GlassmorphismDrawable as a foreground */
    public static void setViewIncludedInBlur(View view, boolean included) {
        if (view == null) throw new IllegalArgumentException("Null View argument in setViewIncludedInBlur.");
        includeViewsStatus.put(view, included);
        if (blurGeneratingStarted) view.invalidate();
    }
    
    /* This method adds a general blur radius to all non specified views
    
    * This method doesn't effect the setBlurRadius method (When you apply a specified blur value to a view, the generator ignores the default value)
    
    * This method must be called before startGeneratingBlur
    
    * Blur radius is always confined between 0 and 25 */
    public static void setDefaultBlurRadius(int radius) {
        if (radius < 0 || radius > 25) throw new IllegalArgumentException("Blur radius must be a positive number and less or equals to 25, given value : ".concat(String.valueOf(radius)));
        if (blurGeneratingStarted) throw new IllegalStateException("setDefaultBlurRadius method must be called before startGeneratingBlur.");
        defaultBlurRadius = radius;
    }
    
    
    /* And all the magic happens here :) */
    /* We must trigger this method in order to apply the Glassmorphism effect to our views */
    /* All the generated bitmaps here takes the size of its views so I think its memory safe if you're not applying it to big/a lot of views */
    public static void startGeneratingBlur() {
        blurGeneratingStarted = true;
        for (final View view : new ArrayList<View>(listeners.keySet())) {
            ViewTreeObserver.OnPreDrawListener onpredrawlistener = new ViewTreeObserver.OnPreDrawListener() {
                boolean dontCallOnPreDraw;
                @Override
                public boolean onPreDraw() {
                    if (dontCallOnPreDraw) return false;
                    int blurRadius = blurRadiusForEachView.containsKey(view) ? blurRadiusForEachView.get(view) : 25;
                    if (blurRadius == 0) {
                        listeners.get(view).whenResetBlur(view);
                        listeners.get(view).whenBlurIsReady(view, new GlassmorphismDrawable(view, null));
                        return true;
                    }
                    boolean includeView = includeViewsStatus.containsKey(view) ? includeViewsStatus.get(view) : false;
                    dontCallOnPreDraw = true;
                    int previousViewVisibility = view.getVisibility();
                    if (! includeView) view.setVisibility(View.INVISIBLE);
                    listeners.get(view).whenResetBlur(view);
                    ViewGroup actRoot = (ViewGroup) relatedWindow.getDecorView().getRootView();
                    int[] viewCoords = new int[2];
                    view.getLocationInWindow(viewCoords);
                    Bitmap viewBackgroundBitmap = Bitmap.createBitmap(view.getMeasuredWidth() + blurRadius*2, view.getMeasuredHeight() + blurRadius*2, Bitmap.Config.ARGB_8888);
                    Canvas resultBlurCanvas = new Canvas(viewBackgroundBitmap);
                    resultBlurCanvas.translate((float)(blurRadius - viewCoords[0]), (float)(blurRadius - viewCoords[1]));
                    actRoot.draw(resultBlurCanvas);
                    final Bitmap resultBlur = Toolkit.INSTANCE.blur(viewBackgroundBitmap, blurRadius);
                    listeners.get(view).whenBlurIsReady(view, new GlassmorphismDrawable(view, resultBlur));
                    view.setVisibility(previousViewVisibility);
                    dontCallOnPreDraw = false;
                    return true;
                }
            };
            view.getViewTreeObserver().addOnPreDrawListener(onpredrawlistener);
            cachedOnPreDrawListeners.put(view, onpredrawlistener);
        }
    }
    
    /* This method stops generating Glassmorphism effect */
    public static void stopGeneratingBlur() {
        for (final View view : new ArrayList<View>(cachedOnPreDrawListeners.keySet())) {
            view.getViewTreeObserver().removeOnPreDrawListener(cachedOnPreDrawListeners.get(view));
            cachedOnPreDrawListeners.remove(view);
        }
        blurGeneratingStarted = false;
    }
    
    /* This method checks if blur generating is started */
    public static boolean isBlurGeneratingStarted() {
        return blurGeneratingStarted;
    }
}
